<!DOCTYPE html>
<html lang="zh" xmlns:v-on="http://www.w3.org/1999/xhtml" xmlns:v-bind="http://www.w3.org/1999/xhtml">
<script type="text/javascript" src="/static/js/vue@2.7.16.js"></script>
<script type="text/javascript" src="/static/jquery/jquery.min.js?ver={{js_ver}}"></script>
<script type="text/javascript" src="/static/js/rg_base.js?ver={{js_ver}}"></script>
<script type="text/javascript" src="/static/js/file.js?ver={{js_ver}}"></script>
<script type="text/javascript" src="/static/js/MimeType.js?ver={{js_ver}}"></script>
<script type="text/javascript" src="/static/js/bgLayout.js?ver={{js_ver}}"></script>

<script type="text/javascript" src="/static/pinyin/pinyin_dict_notone.js?ver={{js_ver}}"></script>
<script type="text/javascript" src="/static/pinyin/pinyinUtil.js?ver={{js_ver}}"></script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
<script type="text/javascript" src="/static/js/epub.min.js?ver={{js_ver}}"></script>

<style>
    .full,
    html,
    body {
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
    }

    .center {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    video {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    audio {
        width: 100%;
        object-fit: contain;
        align-self: flex-end;
        transition: opacity 0.6s ease;
    }

    .no-support {
        color: #ecf6fd;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
    }

    .no-support img {
        max-width: 80%;
        max-height: 50%;
    }

    .menu {
        position: absolute;
        right: 20px;
        top: 20px;
        height: 20px;
        transform: scaleX(-1);
        cursor: pointer;
    }

    .pointer {
        cursor: pointer;
    }

    .download {
        height: 20px;
        cursor: pointer;
        top: 0;
        right: 0;
    }

    .menu-base {
        border-radius: 5px;
        position: absolute;
        right: 20px;
        top: 60px;
        background-color: #2b2b2b;
        color: #ecf6fd;
        overflow: auto;
        overflow-x: hidden;
        max-width: 300px;
        width: 80%;
    }

    .menu-base::-webkit-scrollbar,
    .menu-base ul::-webkit-scrollbar {
        background-color: rgba(0, 0, 0, 0);
        width: 10px;
    }

    .menu-base::-webkit-scrollbar-thumb,
    .menu-base ul::-webkit-scrollbar-thumb {
        background-color: gray;
        border-radius: 5px;
        text-align: center;
    }

    .scroll-text {
        white-space: nowrap;
        text-overflow: ellipsis;
        width: fit-content;
        animation: scroll 10s linear infinite;
        color: mintcream;
        padding-top: 10px;
        padding-bottom: 10px;
        font-size: small;
    }

    @keyframes scroll {
        0% {
            transform: translateX(0%);
        }

        100% {
            transform: translateX(-50%);
        }
    }

    .play-list {}

    .play-list ul {
        list-style-type: none;
        list-style-image: none;
        max-height: 320px;
        overflow: auto;
        margin: 0;
        padding: 0;
    }

    .play-list li {
        /*padding-left: 40px;*/
        padding-top: 3px;
        padding-bottom: 3px;
        padding-right: 10px;
        cursor: pointer;
        min-height: 40px;
        display: flex;
        align-items: center;
        font-size: 12px;
    }

    .play-list .odd {
        background-color: #262626;
    }

    .play-list .even {
        background-color: #303030;
    }

    .play-list .selected {
        background-color: #4d5157;
    }

    .playing-icon {
        /*position: absolute;*/
        height: 15px;
        left: 17px;
        min-width: 40px;
        text-align: center;
    }

    .play-list .playing {
        /*background-color: #121212;*/
        background-color: #3d67d8;
    }

    .play-list .tool {
        height: 18px;
        width: 25px;
        float: right;
        margin-right: 6px;
        cursor: pointer;
        margin-top: 4px;
        margin-bottom: 4px;
    }

    .play-list .tool-disable {
        filter: brightness(40%);
        /*filter: invert(10%) sepia(70%) saturate(1688%) hue-rotate(193deg) brightness(94%) contrast(87%);*/
    }

    .background {
        width: 100%;
        height: 100%;
        background-size: 100% 100%;
        background-repeat: no-repeat;
        position: absolute;
        filter: blur(60px)
    }

    .search-input {
        width: 100%;
        box-sizing: border-box;
        background-color: transparent;
        color: #ecf6fd;
        border: transparent 0px;
        padding: 5px;
    }

    .full-ab {
        height: 100%;
        width: 100%;
        position: absolute;
    }

    .center-column {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .list-style-none {
        list-style-type: none;
        list-style-image: none;
    }

    .arrow {
        position: fixed;
        top: 50%;
        margin-top: -32px;
        font-size: 64px;
        color: #E2E2E2;
        font-family: arial, sans-serif;
        font-weight: bold;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
        text-decoration: none;
    }

    #prev {
        left: 0;
    }

    #next {
        right: 0;
    }

    @media (min-width: 1000px) {
        #epubArea.spreads:after {
            position: absolute;
            width: 1px;
            border-right: 1px #000 solid;
            height: 90%;
            z-index: 1;
            left: 50%;
            margin-left: -1px;
            top: 5%;
            opacity: .15;
            box-shadow: -2px 0 15px rgba(0, 0, 0, 1);
            content: "";
        }

        #epubArea.spreads.single:after {
            display: none;
        }

        #prev {
            left: 40px;
        }

        #next {
            right: 40px;
        }
    }

    .epub-size {
        width: 86%;
        height: 90%;
        overflow: hidden;
    }

    .epub-size-phone {
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    .epub-bg {
        background-color: rgb(252, 248, 237);
    }

    .transition {
        transition: all 0.4s ease-in-out;
    }

    .transition1 {
        transition: all 1.0s ease-in-out;
    }

    .shadow {
        box-shadow: 0 3px 6px 1px rgba(0, 0, 0, .22);
    }

    .epub-chapter-wrapper {
        max-height: 80%;
        overflow: auto;
        margin: 0;
        padding: 0;
    }

    .epub-item {
        cursor: pointer;
        padding-top: 3px;
        padding-bottom: 3px;
        padding-right: 10px;
        font-size: 12px;
    }

    .epub-bold {
        font-weight: bold;
    }

    .epub-ul {
        padding-left: 20px;
    }
</style>

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=1.0, user-scalable=yes" />
    <title>预览</title>
    {% raw %}
    <script type="text/x-template" id="item-template">
        <li>
          <div
            :class="'epub-bold'"
            @click="$emit('select', item)">
            {{ item.label }}
          </div>
          <ul class="epub-ul" v-show="isOpen" v-if="isFolder">
            <tree-item
              class="epub-item"
              v-for="(child, index) in item.subitems"
              :key="index"
              :item="child"
              @select="$emit('select', $event)"
            ></tree-item>
          </ul>
        </li>
    </script>
    {% endraw %}
</head>

<body class="center" style="background-color: #4b4b4b;" onresize="onResize(event)">

    {% raw %}
    <div id="videoPage" ref="videoPage" class="full center" @click="onBackgroundClick"
        @dblclick="onBackgroundDoubleClick">
        <div v-if="url && audio && audioCover" class="background"
            v-bind:style="{backgroundImage: 'url(' + audioCover + ')' }"></div>
        <img v-if="url && audio && audioCover" v-bind:src="audioCover"
            onerror="this.src='/static/image/music_playing.svg'"
            style="max-width: 80%; max-height: 80%; position: absolute; border-radius: 4px"
            v-bind:style="{maxHeight: Math.min(appHeight * 0.8, 400) + 'px'}">
        <audio v-if="audio" ref="audioPlayer" v-bind:style="{opacity: audioPlayerOpacity}"
            v-bind:autoplay="autoPlay ? 'autoplay' : null" v-bind:loop="autoPlay && loopMode === 2 ? 'loop' : null"
            @click="onAudioPlayerClick" @ended="onEnded()" @play="onStartPlay()" @canplay="onCanplay()" preload="auto"
            controls>
            <source v-bind:src="url" type="audio/mpeg">
            <source v-bind:src="url" type="audio/aac">
            <source v-bind:src="url" type="audio/ogg">
        </audio>

        <video v-if="video" v-bind:src="url" preload="auto" controls>
        </video>

        <img v-if="image" v-bind:src="url" id="oImg" style="max-width: 100%; max-height: 100%">

        <div v-if="loaded && !image && !video && !audio" class="no-support transition"
            v-bind:style="{opacity: previewOpacity}">
            <img id="cover" v-if="loadedFile" v-bind:class="epub ? 'pointer' : ''" v-bind:src="loadedFile.thumb"
                @error="onThumbError(loadedFile)" @click="onThumbClick">
            <div v-if="loadedFile" style="margin-bottom: 40px; margin-top: 20px">{{loadedFile.name}}</div>
            <div v-if="!loadedFile && open_code">共享内容已取消</div>
        </div>

        <div v-if="list && !fileList.length" class="no-support">
            没有可播放的内容
        </div>

        <div v-if="epubLoading" class="full-ab center-column transition">

            <div v-if="epubLoading" class="full-ab center-column transition">
                <div id="epubWrapper"
                    v-bind:class="epubCoverShadow ? epubSize : ['shadow', 'epub-bg', epubSize].join(' ')"
                    style="position: absolute;">
                    <div class="full-ab transition1" style="position: absolute;"
                        v-bind:style="{opacity: epubAreaOpacity}">
                        <div key="epubContent" class="full-ab" v-bind:class="phoneView?'':'spreads'" id="epubArea">
                        </div>
                    </div>
                </div>
                <a v-if="!phoneView" v-bind:style="{opacity: epubAreaOpacity}" id="prev" class="arrow"
                    @click="epubPrev">‹</a>
                <a v-if="!phoneView" v-bind:style="{opacity: epubAreaOpacity}" id="next" class="arrow"
                    @click="epubNext">›</a>
            </div>

            <div v-if="!epubLoaded" v-bind:class="epubCoverShadow ? 'shadow transition': ''"
                v-bind:style="epubCoverShadowStyle">
                <div v-if="epubCoverShow" class="full-ab epub-bg"></div>
            </div>

            <div v-if="!epubLoaded" v-bind:class="epubSize" style="position: absolute;">
                <img v-if="epubCoverShow" key="epubCover" v-bind:src="loadedFile.thumb"
                    @error="onThumbError(loadedFile)" class="transition" v-bind:style="epubCoverStyle" />
            </div>
        </div>

        <img v-if="(list && fileList.length) || (epubLoaded && epubToc)" src="/static/image/menu.svg" class="menu"
            @click="onMenuIconClick" @dblclick="onMenuIconClick">
        <div v-else-if="loadedFile && !epubLoaded" class="menu">
            <img src="/static/image/file-download.svg" class="download">
            <a class="download" style="width: 100%;height: 100%; position: absolute;"
                v-bind:href="loadedFile.downloadUrl" v-bind:download="loadedFile.name"></a>
        </div>

        <div v-if="list && fileList.length && showMenu" class="play-list menu-base" @click="onPlaylistDoubleClick"
            @dblclick="onPlaylistDoubleClick">
            <div v-if="open_code" style="padding-left: 14px; padding-top: 5px; padding-bottom: 5px; font-size: 14px;">
                共享的播放列表</div>
            <div class="scroll-text">
                正在播放：{{loadedFile.name}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正在播放：{{loadedFile.name}}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </div>
            <input v-if="listSearchState" autofocus="autofocus" class="search-input" v-model="audioSearchText"
                placeholder="搜索文件名" @input="doSearch(event.target.value)">
            <ul v-bind:style="{maxHeight: Math.min(appHeight - 130, 300) + 'px'}">
                <li v-for="(file, index) in displayList" v-bind:class="(index%2 == 0 ? 'odd' : 'even') + ' ' +
                (selectedId == file.id ? 'selected' : '') + ' ' +
                (willPlayId == file.id ? 'playing': '')" @click="select(file.id)"
                    @dblclick="onAudioDoubleClick(file.id)" onselectstart="return false">
                    <img v-if="playingId == file.id" @click="switchPlayState(file.id)"
                        src="/static/image/list_playing.svg" class="playing-icon">
                    <div v-else class="playing-icon">{{index + 1}} </div>
                    <span>
                        <span class="two_line">{{file.name}}</span>
                    </span>
                </li>
            </ul>
            <img class="tool" v-bind:class="!autoPlay ? 'tool-disable' : ''" src="/static/image/list_auto.svg"
                @click="switchAutoPlay">
            <img class="tool" v-bind:class="!autoPlay ? 'tool-disable' : ''" v-bind:src="loopModes[loopMode]"
                @click="switchLoopMode">
            <img class="tool" src="/static/image/list-search.svg" @click="onSearch">
            <img class="tool" src="/static/image/list_locate.svg" @click="onScrollToPlaying">
            <img class="tool" src="/static/image/list_next.svg" @click="next(1)">
        </div>

        <div v-if="epub && showMenu && epubToc" class="menu-base epub-chapter-wrapper">
            <tree-item class="epub-item list-style-none" style="padding:16px;"
                :item="{label: loadedFile.name, subitems: epubToc}" @select="gotoToc">
            </tree-item>
        </div>
    </div>

    {% endraw %}

</body>
<script>
    function getUrlSearch(name) {
        [].join()
        if (!name) return null;
        let after = window.location.search;
        after = after.substr(1) || window.location.hash.split('?')[1];
        if (!after) return null;
        if (after.indexOf(name) === -1) return null;
        var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)');
        var r = decodeURI(after).match(reg);
        if (!r) return null;
        return r[2];
    }

    Vue.component("tree-item", {
        template: "#item-template",
        props: {
            item: Object
        },
        data: function () {
            return {
                isOpen: true
            };
        },
        computed: {
            isFolder: function () {
                return this.item.subitems && this.item.subitems.length;
            }
        },
        methods: {
            select: function () {
                this.$emit("select", this.item);
            },
        }
    });

    const videoPage = new Vue({
        el: '#videoPage',
        data: {
            loaded: false,
            mimeType: null,
            video: false,
            image: false,
            audio: false,
            pathFileId: null,
            loadedFile: null,
            list: false,
            url: null,
            audioCover: null,
            willPlayId: null,
            playingId: null,
            selectedId: null,
            fileList: [],
            displayList: [],
            audioSearchText: '',
            autoPlay: false,
            showMenu: false,
            loopMode: 0,
            loopModes: ['/static/image/list_order.svg', '/static/image/list_random.svg', '/static/image/list_one_loop.svg'],
            errorImage: 'this.src="/static/image/music_playing.svg"',
            previewOpacity: 1,
            audioPlayerOpacity: 1,
            backgroundViewClickTimer: null,
            appWidth: 0,
            appHeight: 0,
            listSearchState: false,
            open_code: null,
            phoneView: isPhoneView(),

            epub: false,
            epubLoading: false,
            epubLoaded: false,
            epubCoverShow: false,
            epubCoverStyle: {},
            epubCoverShadowStyle: {},
            epubCoverShadow: true,
            epubAreaOpacity: 0,
            epubSize: isPhoneView() ? "epub-size-phone" : "epub-size",
            epubBook: null,
            epubRendition: null,
            epubToc: null
        },
        created: function (e) {
            window.addEventListener('popstate', this.handlePopState)

            this.updatePathFileId()
            let path = document.location.pathname.split("/")
            let lastPath = path[path.length - 1]
            let sv = null, pv = null
            if (lastPath.indexOf('pv') === 0) {
                pv = lastPath.substr(2)
            } else if (lastPath.indexOf('sv') === 0) {
                sv = lastPath.substr(2)
                document.title = '共享'
                this.open_code = sv
            }
            if (path.indexOf('playList') >= 0) {
                document.title = '播放列表'
                this.loadPlayList(pv, sv)
            } else {
                this.loadFile(pv)
            }
        },
        destroyed() {
            window.removeEventListener('popstate', this.handlePopState)
        },
        mounted: function () {
            this.onResize()
        },
        methods: {
            updatePathFileId: function () {
                URLSearchParams.prototype.toObject = function () {
                    const obj = {}
                    this.forEach((value, key) => {
                        obj[key] = value
                    })
                    return obj
                }
                const params = new URLSearchParams(window.location.search).toObject()
                if ('f' in params) {
                    this.pathFileId = params['f']
                }
            },
            loadPlayList: function (code, open_code) {
                file_list({
                    code,
                    open_code,
                    success: (result) => {
                        this.list = true
                        if (result.code === 1000) {
                            this.autoPlay = true
                            let fileList = result.data
                            let loadId = null
                            fileList = fileList.filter(((file, index, array) => {
                                if (this.pathFileId == file.id) {
                                    loadId = this.pathFileId
                                }
                                file.sortName = pinyinUtil.getPinyin(file.name, '', false, false, false).toLowerCase()
                                file.sortName1 = pinyinUtil.getPinyin(file.name, '', false, false, true).toLowerCase()
                                return audioDisplaySupport(mimeType(file.name))
                            }))
                            fileList.sort((a, b) => {
                                return a.sortName.localeCompare(b.sortName)
                            })
                            this.fileList = fileList
                            this.displayList = fileList
                            this.loadCurrentFile()
                        }
                    },
                    error: function (e) {
                        this.list = true
                    },
                })
            },
            loadCurrentFile: function () {
                let loadId = null
                const fileList = this.fileList
                for (const file of fileList) {
                    if (this.pathFileId == file.id) {
                        loadId = this.pathFileId
                        break
                    }
                }
                this.loadFile(loadId ? loadId : fileList[0].id)
            },
            loadFile: function (fid) {
                if (fid === undefined) {
                    this.loaded = true
                    return
                }
                if (fid !== null) {
                    fid = parseInt(fid)
                }
                userFileInfo({
                    file_id: fid,
                    open_code: this.open_code,
                    error: () => {
                        this.loaded = true
                    },
                    success: (result) => {
                        this.loaded = true
                        if (result.code !== 1000) {
                            return
                        }
                        let file = result.data.file
                        let mime = mimeType(file.name)

                        file.errorThumb = mimeIconUrl(mime)

                        let params = { coverIn: true }
                        if (isPhoneView()) {
                            params['side'] = 1080
                            params['quality'] = 'low'
                        } else {
                            params['side'] = 1920
                        }

                        if (this.open_code) {
                            file.downloadUrl = '/file/user/open/get/' + file.open_code
                            if (file.depend_folder) {
                                file.downloadUrl = file.downloadUrl + '?id=' + file.id
                            }
                        } else {
                            file.downloadUrl = '/file/user/get/' + file.id
                        }
                        file.thumb = file.downloadUrl.my_cover(params)
                        this.updateURLParameterIfNeed('f', file.id)

                        this.loadedFile = file

                        this.mimeType = mime
                        this.image = imageDisplaySupport(mime)
                        this.video = videoDisplaySupport(mime)
                        this.audio = audioDisplaySupport(mime)
                        this.epub = epubDisplaySupport(mime)

                        this.url = ''
                        this.$refs.audioPlayer && this.$refs.audioPlayer.load()

                        this.playingId = null

                        if (this.audio) {
                            this.audioCover = file.thumb
                        }
                        document.title = file.name

                        this.$nextTick(function () {
                            this.url = file.downloadUrl
                            this.willPlayId = fid
                            this.$refs.audioPlayer && this.$refs.audioPlayer.load()
                            this.registMetaData(this.loadedFile)
                        })
                    }
                })
            },
            onCanplay: function () {
                this.$refs.audioPlayer && this.$refs.audioPlayer.play()
            },
            onStartPlay: function () {
                this.playingId = this.willPlayId
            },
            select: function (fid) {
                event.cancelBubble = true
                event.preventDefault()
                this.selectedId = fid
                if (!isPhoneView()) {
                    return
                }
                this.onAudioItemChoice(fid)
            },
            onAudioDoubleClick: function (fid) {
                event.cancelBubble = true
                event.preventDefault()
                if (isPhoneView()) {
                    return
                }
                this.selectedId = fid
                this.onAudioItemChoice(fid)
            },
            onAudioItemChoice: function (fid) {
                let audioPlayer = this.$refs.audioPlayer
                if (this.willPlayId === fid) {
                    this.switchPlayState(fid)
                } else {
                    audioPlayer.pause()
                    this.loadFile(fid)
                }
            },
            switchPlayState: function (fid) {
                if (fid !== this.willPlayId) {
                    return
                }
                let audioPlayer = this.$refs.audioPlayer
                if (audioPlayer.paused) {
                    audioPlayer.play()
                } else {
                    audioPlayer.pause()
                }
            },
            onEnded: function () {
                if (!this.autoPlay) {
                    return
                }
                this.next()
            },
            next: function (user) {
                let nextIndex = this.fileList.findIndex(file => file.id === this.playingId)
                let loopMode = this.loopMode
                if (loopMode === 2 && user) {
                    loopMode = 0
                }
                switch (loopMode) {
                    case 0:
                        if (nextIndex + 1 < this.fileList.length) {
                            nextIndex = nextIndex + 1
                        } else {
                            nextIndex = 0
                        }
                        break
                    case 1:
                        nextIndex = Math.floor(Math.random() * this.fileList.length)
                        break
                    case 2:
                    default:
                        break
                }
                this.loadFile(this.fileList[nextIndex].id)
            },
            switchLoopMode: function (e) {
                e.cancelBubble = true
                let loopMode = this.loopMode
                loopMode++
                if (loopMode >= this.loopModes.length) {
                    loopMode = 0
                }
                this.loopMode = loopMode
            },
            switchAutoPlay: function (e) {
                e.cancelBubble = true
                this.autoPlay = !this.autoPlay
            },
            onMenuIconClick: function (e) {
                e.cancelBubble = true
                this.showMenu = !this.showMenu
            },
            onSearch: function (e) {
                e.cancelBubble = true
                this.listSearchState = !this.listSearchState
                if (this.listSearchState) {
                    this.doSearch('')
                } else {
                    this.displayList = this.fileList
                }
            },
            doSearch: function (text) {
                this.audioSearchText = text
                text = text.toLowerCase()
                this.displayList = this.fileList.filter(((file, index, array) => {
                    return file.sortName.indexOf(text) >= 0 || file.name.indexOf(text) >= 0 || file.sortName1.indexOf(text) >= 0
                }))
            },
            onScrollToPlaying: function (e) {
                e.cancelBubble = true
                let playingView = document.getElementsByClassName('playing')[0]
                playingView && playingView.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                })
            },
            onPlaylistDoubleClick: function (e) {
                e.cancelBubble = true
            },
            onBackgroundClick: function (e) {
                e.cancelBubble = true
                this.backgroundViewClickTimer && clearTimeout(this.backgroundViewClickTimer)
                this.backgroundViewClickTimer = setTimeout(() => {
                    if (this.audio) {
                        this.audioPlayerOpacity = this.audioPlayerOpacity ? 0 : 1
                    }
                }, 200);
            },
            onBackgroundDoubleClick: function (e) {
                e.cancelBubble = true
                this.backgroundViewClickTimer && clearTimeout(this.backgroundViewClickTimer)
                if (this.audio) {
                    if (!document.fullscreenElement) {
                        this.enterFullScreen();
                    } else {
                        this.exitFullScreen();
                    }
                }
            },
            enterFullScreen() {
                let element = document.documentElement;
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.mozRequestFullScreen) { /* Firefox */
                    element.mozRequestFullScreen();
                } else if (element.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    element.webkitRequestFullscreen();
                } else if (element.msRequestFullscreen) { /* IE/Edge */
                    element.msRequestFullscreen();
                }
            },
            exitFullScreen() {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
            },
            onAudioPlayerClick: function (e) {
                e.cancelBubble = true
            },
            onResize: function () {
                // console.log(this.$refs.videoPage.offsetHeight)
                this.appHeight = this.$refs.videoPage.offsetHeight
                this.appWidth = this.$refs.videoPage.offsetWidth
                if (this.epubLoading && !this.epubLoaded) {

                    let cover = document.getElementById("cover");
                    let style = getFrame(cover, true)
                    let rate = parseFloat(style.width) / parseFloat(style.height)

                    this.epubCoverStyle = this.getCoverStyle(rate, 'epubWrapper', false)
                    this.epubCoverShadowStyle = this.getCoverStyle(rate, 'epubWrapper', false)
                }
            },
            onThumbError(file) {
                file.thumb = file.errorThumb
            },
            onThumbClick: function (e) {
                if (this.epub) {
                    this.showBook()
                    return
                }
            },
            showBook: function () {
                if (this.epubLoading || this.epubLoaded) {
                    return
                }

                let cover = document.getElementById("cover");

                let style = getFrame(cover, true)
                let rate = parseFloat(style.width) / parseFloat(style.height)

                this.epubLoading = true
                this.epubAreaOpacity = 0
                this.epubCoverShadow = true
                this.epubLoaded = false
                style = this.getCoverStyle(rate, 'cover', false)

                this.epubCoverShadowStyle = this.getCoverStyle(rate, 'cover', false)

                this.$nextTick(() => {
                    setTimeout(() => {

                        this.previewOpacity = 0
                        this.epubCoverShadowStyle = this.getCoverStyle(rate, 'cover', false)

                        let frame = getFrame('epubWrapper')
                        let style = this.getCoverStyle(rate, 'cover', false)

                        style.left = parseFloat(style.left) - frame.x + 'px'
                        style.top = parseFloat(style.top) - frame.y + 'px'
                        this.epubCoverStyle = style
                        this.epubCoverShow = true

                        this.$nextTick(() => {
                            setTimeout(() => {
                                this.epubCoverStyle = this.getCoverStyle(rate, 'epubWrapper', true)
                                this.epubCoverShadowStyle = this.getCoverStyle(rate, 'epubWrapper', false)

                                this.loadEpub('epubArea', this.loadedFile.downloadUrl + "/", () => {
                                    this.epubCoverStyle = this.getCoverStyle(rate, 'epubWrapper', true)
                                    this.epubCoverShadowStyle = this.getCoverStyle(rate, 'epubWrapper', false)

                                    this.$nextTick(() => {
                                        setTimeout(() => {
                                            let style = this.getCoverStyle(rate, 'epubWrapper', true)
                                            style.left = (-parseFloat(style.width)) + 'px'
                                            this.epubCoverStyle = style

                                            style = getFrame('epubWrapper', true)
                                            this.epubCoverShadowStyle = style

                                            this.epubAreaOpacity = 1

                                            this.$nextTick(() => {
                                                setTimeout(() => {
                                                    this.epubCoverShadow = false
                                                    this.epubLoaded = true
                                                }, 400);
                                            });
                                        }, 400);
                                    });
                                });
                            }, 10);
                        })
                    }, 10);
                })
            },
            getCoverStyle: function (rate, inContainer, relateContainer) {
                let style = getFrame(inContainer, true)

                let width = parseFloat(style.width)
                let height = parseFloat(style.height)
                let left = parseFloat(style.left)
                let top = parseFloat(style.top)

                let _rate = width / height

                if (_rate > rate) {

                    style.width = height * rate + 'px'
                    style.left = (width - height * rate) / 2.0
                    if (!relateContainer) {
                        style.left += left
                    } else {
                        style.top = 0
                    }
                    style.left += 'px'
                } else {
                    style.height = width / rate + 'px'
                    style.top = (height - width / rate) / 2.0
                    if (!relateContainer) {
                        style.top += top
                    } else {
                        style.left = 0
                    }
                    style.top += 'px'
                }
                return style
            },
            loadEpub: function (div, url, complete) {
                var book = ePub(url);
                let phoneView = isPhoneView()
                let params = {
                    flow: phoneView ? "scrolled" : "paginated",
                    // snap: true,
                    width: "100%",
                    height: "100%",
                    // spread: "always"
                }
                if (phoneView) {
                    params.manager = "continuous"
                }
                var rendition = book.renderTo(div, params)

                var pageKey = 'epubPage_' + this.loadedFile.id
                let cfi = localStorage.getItem(pageKey)
                if (cfi) {
                    rendition.display(cfi)
                } else {
                    rendition.display()
                }

                this.epubBook = book
                this.epubRendition = rendition

                book.ready.then(() => {
                    book.loaded.navigation.then((toc) => {
                        this.epubToc = toc.toc
                    })

                    rendition.on("relocated", (relocated) => {
                        localStorage.setItem(pageKey, relocated.start.cfi)
                    });

                    setTimeout(() => {
                        complete()
                    }, 400);

                    if (phoneView) {
                        return
                    }

                    var keyListener = function (e) {

                        // Left Key
                        if ((e.keyCode || e.which) == 37) {
                            book.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev();
                        }

                        // Right Key
                        if ((e.keyCode || e.which) == 39) {
                            book.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next();
                        }

                    };
                    rendition.on("keyup", keyListener);
                    document.addEventListener("keyup", keyListener, false);
                })
            },
            epubPrev: function (e) {
                const rendition = this.epubRendition
                this.epubBook.package.metadata.direction === "rtl" ? rendition.next() : rendition.prev()
                e.preventDefault()
            },
            epubNext: function (e) {
                const rendition = this.epubRendition
                this.epubBook.package.metadata.direction === "rtl" ? rendition.prev() : rendition.next()
                e.preventDefault()
            },
            gotoToc: function (toc) {
                var skip = this.epubRendition.display(toc.href);
                skip.then(function () {

                })
            },
            updateURLParameterIfNeed: function (param, value) {
                if (this.fileList.length <= 0) {
                    return;
                }
                var currentUrl = new URL(window.location)
                if (currentUrl.searchParams.get(param) == value) {
                    return
                }
                currentUrl.searchParams.set(param, value)
                history.pushState({ path: currentUrl.pathname }, '', currentUrl.toString())
            },
            handlePopState: function (event) {
                if (this.fileList.length <= 0) {
                    return
                }
                this.updatePathFileId()
                this.loadCurrentFile()
            },
            registMetaData: function (file) {
                let navigator = window.navigator
                if (!navigator.mediaSession) {
                    return
                }
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: file.name,
                    artwork: [
                        {
                            src: file.thumb,
                            type: "image/png",
                        }
                    ],
                })

                const audioPlayer = this.$refs.audioPlayer;
                if (!audioPlayer) {
                    return
                }

                navigator.mediaSession.playbackState = 'playing'

                navigator.mediaSession.setActionHandler("play", () => {
                    audioPlayer.play();
                })

                // 设置暂停操作
                navigator.mediaSession.setActionHandler("pause", () => {
                    audioPlayer.pause();
                    navigator.mediaSession.playbackState = 'paused'
                })

                // 设置停止操作
                navigator.mediaSession.setActionHandler("stop", () => {
                    navigator.mediaSession.playbackState = 'stopped'
                        (audioPlayer.pause(), audioPlayer.currentTime = 0)
                })

                // 设置回退操作
                navigator.mediaSession.setActionHandler("seekbackward", () => {
                    const newTime = Math.max(audioPlayer.currentTime - 10, 0) // 回退10秒
                    audioPlayer.currentTime = newTime;
                })

                // 设置快进操作
                navigator.mediaSession.setActionHandler("seekforward", () => {
                    const newTime = Math.min(audioPlayer.currentTime + 10, audioPlayer.duration) // 快进10秒
                    audioPlayer.currentTime = newTime
                })

                // 设置跳转到指定时间点操作
                navigator.mediaSession.setActionHandler("seekto", (details) => {
                    if (details.seekTime) {
                        const newTime = Math.min(details.seekTime, audioPlayer.duration) // 确保时间不超过音频总时长
                        audioPlayer.currentTime = newTime
                    }
                })

                // 设置上一首操作
                navigator.mediaSession.setActionHandler("previoustrack", () => {
                    history.back()
                })

                // 设置下一首操作
                navigator.mediaSession.setActionHandler("nexttrack", () => {
                    this.next(1)
                })
            }
        },
    });

    function onResize(e) {
        videoPage.onResize()
    }
</script>

</html>